/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.zyre

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import org.zeromq.czmq.*

class Zyre {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("czmq", false)
//        libraries.put("zyre", false)
//        libraries.put("zyrejni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zyre_new(name: String): Pointer
        fun destroy(self: Pointer)
        fun zyre_uuid(self: Pointer): String
        fun zyre_name(self: Pointer): String
        fun zyre_set_name(self: Pointer, name: String): Unit
        fun zyre_set_header(self: Pointer, name: String, format: Array<out String>): Unit
        fun zyre_set_verbose(self: Pointer): Unit
        fun zyre_set_port(self: Pointer, portNbr: Int): Unit
        fun zyre_set_beacon_peer_port(self: Pointer, portNbr: Int): Unit
        fun zyre_set_evasive_timeout(self: Pointer, interval: Int): Unit
        fun zyre_set_silent_timeout(self: Pointer, interval: Int): Unit
        fun zyre_set_expired_timeout(self: Pointer, interval: Int): Unit
        fun zyre_set_interval(self: Pointer, interval: Pointer): Unit
        fun zyre_set_interface(self: Pointer, value: String): Unit
        fun zyre_set_endpoint(self: Pointer, format: Array<out String>): Int
        fun zyre_set_contest_in_group(self: Pointer, group: String): Unit
        fun zyre_set_advertised_endpoint(self: Pointer, value: String): Unit
        fun zyre_set_zcert(self: Pointer, zcert: Pointer): Unit
        fun zyre_set_zap_domain(self: Pointer, domain: String): Unit
        fun zyre_gossip_bind(self: Pointer, format: Array<out String>): Unit
        fun zyre_gossip_connect(self: Pointer, format: Array<out String>): Unit
        fun zyre_gossip_connect_curve(self: Pointer, publicKey: String, format: Array<out String>): Unit
        fun zyre_gossip_unpublish(self: Pointer, node: String): Unit
        fun zyre_start(self: Pointer): Int
        fun zyre_stop(self: Pointer): Unit
        fun zyre_join(self: Pointer, group: String): Int
        fun zyre_leave(self: Pointer, group: String): Int
        fun zyre_recv(self: Pointer): Pointer
        fun zyre_whisper(self: Pointer, peer: String, msgP: Pointer): Int
        fun zyre_shout(self: Pointer, group: String, msgP: Pointer): Int
        fun zyre_whispers(self: Pointer, peer: String, format: Array<out String>): Int
        fun zyre_shouts(self: Pointer, group: String, format: Array<out String>): Int
        fun zyre_peers(self: Pointer): Pointer
        fun zyre_peers_by_group(self: Pointer, name: String): Pointer
        fun zyre_own_groups(self: Pointer): Pointer
        fun zyre_peer_groups(self: Pointer): Pointer
        fun zyre_peer_address(self: Pointer, peer: String): String
        fun zyre_peer_header_value(self: Pointer, peer: String, name: String): String
        fun zyre_require_peer(self: Pointer, uuid: String, endpoint: String, publicKey: String): Int
        fun zyre_socket(self: Pointer): Pointer
        fun zyre_socket_zmq(self: Pointer): Pointer
        fun zyre_print(self: Pointer): Unit
        fun zyre_version(): Long
        fun zyre_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("zyre", NativeLib::class.java)

    /**
     * Return the Zyre version for run-time API detection; returns
     * major * 10000 + minor * 100 + patch, as a single integer.
     */
    fun version(): Long {
        return nativeLib.zyre_version()
    }

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zyre_test(verbose)
    }

    }

    var self: Pointer

    /**
     * Constructor, creates a new Zyre node. Note that until you start the
     * node it is silent and invisible to other nodes on the network.
     * The node name is provided to other nodes during discovery. If you
     * specify NULL, Zyre generates a randomized node name from the UUID.
     */
    constructor(name: String) {
        /*  TODO: if __new fails, self is null...            */
        self = nativeLib.zyre_new(name)
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

    /**
     * Destructor, destroys a Zyre node. When you destroy a node, any
     * messages it is sending or receiving will be discarded.
     */
//    @Override
//    public void close () {
//        nativeLib.zyre_destroy(self)
//        self = 0
//    }
//
    /**
     * Return our node UUID string, after successful initialization
     */
    fun uuid(): String {
        return nativeLib.zyre_uuid(self)
    }

    /**
     * Return our node name, after successful initialization. First 6
     * characters of UUID by default.
     */
    fun name(): String {
        return nativeLib.zyre_name(self)
    }

    /**
     * Set the public name of this node overriding the default. The name is
     * provide during discovery and come in each ENTER message.
     */
    fun setName(name: String): Unit {
        nativeLib.zyre_set_name(self, name)
    }

    /**
     * Set node header; these are provided to other nodes during discovery
     * and come in each ENTER message.
     */
    fun setHeader(name: String, vararg format: String): Unit {
        nativeLib.zyre_set_header(self, name, format)
    }

    /**
     * Set verbose mode; this tells the node to log all traffic as well as
     * all major events.
     */
    fun setVerbose(): Unit {
        nativeLib.zyre_set_verbose(self)
    }

    /**
     * Set UDP beacon discovery port; defaults to 5670, this call overrides
     * that so you can create independent clusters on the same network, for
     * e.g. development vs. production. Has no effect after zyre_start().
     */
    fun setPort(portNbr: Int): Unit {
        nativeLib.zyre_set_port(self, portNbr)
    }

    /**
     * Set the TCP port bound by the ROUTER peer-to-peer socket (beacon mode).
     * Defaults to * (the port is randomly assigned by the system).
     * This call overrides this, to bypass some firewall issues when ports are
     * random. Has no effect after zyre_start().
     */
    fun setBeaconPeerPort(portNbr: Int): Unit {
        nativeLib.zyre_set_beacon_peer_port(self, portNbr)
    }

    /**
     * Set the peer evasiveness timeout, in milliseconds. Default is 5000.
     * This can be tuned in order to deal with expected network conditions
     * and the response time expected by the application. This is tied to
     * the beacon interval and rate of messages received.
     */
    fun setEvasiveTimeout(interval: Int): Unit {
        nativeLib.zyre_set_evasive_timeout(self, interval)
    }

    /**
     * Set the peer silence timeout, in milliseconds. Default is 5000.
     * This can be tuned in order to deal with expected network conditions
     * and the response time expected by the application. This is tied to
     * the beacon interval and rate of messages received.
     * Silence is triggered one second after the timeout if peer has not
     * answered ping and has not sent any message.
     * NB: this is currently redundant with the evasiveness timeout. Both
     * affect the same timeout value.
     */
    fun setSilentTimeout(interval: Int): Unit {
        nativeLib.zyre_set_silent_timeout(self, interval)
    }

    /**
     * Set the peer expiration timeout, in milliseconds. Default is 30000.
     * This can be tuned in order to deal with expected network conditions
     * and the response time expected by the application. This is tied to
     * the beacon interval and rate of messages received.
     */
    fun setExpiredTimeout(interval: Int): Unit {
        nativeLib.zyre_set_expired_timeout(self, interval)
    }

    /**
     * Set UDP beacon discovery interval, in milliseconds. Default is instant
     * beacon exploration followed by pinging every 1,000 msecs.
     */
    fun setInterval(interval: Pointer): Unit {
        nativeLib.zyre_set_interval(self, interval)
    }

    /**
     * Set network interface for UDP beacons. If you do not set this, CZMQ will
     * choose an interface for you. On boxes with several interfaces you should
     * specify which one you want to use, or strange things can happen.
     * The interface may by specified by either the interface name e.g. "eth0" or
     * an IP address associalted with the interface e.g. "192.168.0.1"
     */
    fun setInterface(value: String): Unit {
        nativeLib.zyre_set_interface(self, value)
    }

    /**
     * By default, Zyre binds to an ephemeral TCP port and broadcasts the local
     * host name using UDP beaconing. When you call this method, Zyre will use
     * gossip discovery instead of UDP beaconing. You MUST set-up the gossip
     * service separately using zyre_gossip_bind() and _connect(). Note that the
     * endpoint MUST be valid for both bind and connect operations. You can use
     * inproc://, ipc://, or tcp:// transports (for tcp://, use an IP address
     * that is meaningful to remote as well as local nodes). Returns 0 if
     * the bind was successful, else -1.
     */
    fun setEndpoint(vararg format: String): Int {
        return nativeLib.zyre_set_endpoint(self, format)
    }

    /**
     * This options enables a peer to actively contest for leadership in the
     * given group. If this option is not set the peer will still participate in
     * elections but never gets elected. This ensures that a consent for a leader
     * is reached within a group even though not every peer is contesting for
     * leadership.
     */
    fun setContestInGroup(group: String): Unit {
        nativeLib.zyre_set_contest_in_group(self, group)
    }

    /**
     * Set an alternative endpoint value when using GOSSIP ONLY. This is useful
     * if you're advertising an endpoint behind a NAT.
     */
    fun setAdvertisedEndpoint(value: String): Unit {
        nativeLib.zyre_set_advertised_endpoint(self, value)
    }

    /**
     * Apply a azcert to a Zyre node.
     */
    fun setZcert(zcert: Zcert): Unit {
        nativeLib.zyre_set_zcert(self, zcert.self)
    }

    /**
     * Specify the ZAP domain (for use with CURVE).
     */
    fun setZapDomain(domain: String): Unit {
        nativeLib.zyre_set_zap_domain(self, domain)
    }

    /**
     * Set-up gossip discovery of other nodes. At least one node in the cluster
     * must bind to a well-known gossip endpoint, so other nodes can connect to
     * it. Note that gossip endpoints are completely distinct from Zyre node
     * endpoints, and should not overlap (they can use the same transport).
     */
    fun gossipBind(vararg format: String): Unit {
        nativeLib.zyre_gossip_bind(self, format)
    }

    /**
     * Set-up gossip discovery of other nodes. A node may connect to multiple
     * other nodes, for redundancy paths. For details of the gossip network
     * design, see the CZMQ zgossip class.
     */
    fun gossipConnect(vararg format: String): Unit {
        nativeLib.zyre_gossip_connect(self, format)
    }

    /**
     * Set-up gossip discovery with CURVE enabled.
     */
    fun gossipConnectCurve(publicKey: String, vararg format: String): Unit {
        nativeLib.zyre_gossip_connect_curve(self, publicKey, format)
    }

    /**
     * Unpublish a GOSSIP node from local list, useful in removing nodes from list when they EXIT
     */
    fun gossipUnpublish(node: String): Unit {
        nativeLib.zyre_gossip_unpublish(self, node)
    }

    /**
     * Start node, after setting header values. When you start a node it
     * begins discovery and connection. Returns 0 if OK, -1 if it wasn't
     * possible to start the node.
     */
    fun start(): Int {
        return nativeLib.zyre_start(self)
    }

    /**
     * Stop node; this signals to other peers that this node will go away.
     * This is polite; however you can also just destroy the node without
     * stopping it.
     */
    fun stop(): Unit {
        nativeLib.zyre_stop(self)
    }

    /**
     * Join a named group; after joining a group you can send messages to
     * the group and all Zyre nodes in that group will receive them.
     */
    fun join(group: String): Int {
        return nativeLib.zyre_join(self, group)
    }

    /**
     * Leave a group
     */
    fun leave(group: String): Int {
        return nativeLib.zyre_leave(self, group)
    }

    /**
     * Receive next message from network; the message may be a control
     * message (ENTER, EXIT, JOIN, LEAVE) or data (WHISPER, SHOUT).
     * Returns zmsg_t object, or NULL if interrupted
     */
    fun recv(): Zmsg {
        return Zmsg (nativeLib.zyre_recv(self))
    }

    /**
     * Send message to single peer, specified as a UUID string
     * Destroys message after sending
     */
    fun whisper(peer: String, msgP: Zmsg): Int {
        return nativeLib.zyre_whisper(self, peer, msgP.self)
    }

    /**
     * Send message to a named group
     * Destroys message after sending
     */
    fun shout(group: String, msgP: Zmsg): Int {
        return nativeLib.zyre_shout(self, group, msgP.self)
    }

    /**
     * Send formatted string to a single peer specified as UUID string
     */
    fun whispers(peer: String, vararg format: String): Int {
        return nativeLib.zyre_whispers(self, peer, format)
    }

    /**
     * Send formatted string to a named group
     */
    fun shouts(group: String, vararg format: String): Int {
        return nativeLib.zyre_shouts(self, group, format)
    }

    /**
     * Return zlist of current peer ids.
     */
    fun peers(): Zlist {
        return Zlist (nativeLib.zyre_peers(self))
    }

    /**
     * Return zlist of current peers of this group.
     */
    fun peersByGroup(name: String): Zlist {
        return Zlist (nativeLib.zyre_peers_by_group(self, name))
    }

    /**
     * Return zlist of currently joined groups.
     */
    fun ownGroups(): Zlist {
        return Zlist (nativeLib.zyre_own_groups(self))
    }

    /**
     * Return zlist of groups known through connected peers.
     */
    fun peerGroups(): Zlist {
        return Zlist (nativeLib.zyre_peer_groups(self))
    }

    /**
     * Return the endpoint of a connected peer.
     * Returns empty string if peer does not exist.
     */
    fun peerAddress(peer: String): String {
        return nativeLib.zyre_peer_address(self, peer)
    }

    /**
     * Return the value of a header of a conected peer.
     * Returns null if peer or key doesn't exits.
     */
    fun peerHeaderValue(peer: String, name: String): String {
        return nativeLib.zyre_peer_header_value(self, peer, name)
    }

    /**
     * Explicitly connect to a peer
     */
    fun requirePeer(uuid: String, endpoint: String, publicKey: String): Int {
        return nativeLib.zyre_require_peer(self, uuid, endpoint, publicKey)
    }

    /**
     * Return socket for talking to the Zyre node, for polling
     */
    fun socket(): Zsock {
        return Zsock (nativeLib.zyre_socket(self))
    }

    /**
     * Return underlying ZMQ socket for talking to the Zyre node,
     * for polling with libzmq (base ZMQ library)
     */
    fun socketZmq(): Pointer {
        return nativeLib.zyre_socket_zmq(self)
    }

    /**
     * Print zyre node information to stdout
     */
    fun print(): Unit {
        nativeLib.zyre_print(self)
    }

}
